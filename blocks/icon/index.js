const {
  createElement,
  Fragment,
  useState
} = wp.element;
const {
  registerBlockType
} = wp.blocks;
const {
  InspectorControls,
  useBlockProps,
  PanelColorSettings,
  RichText,
  URLInput
} = wp.blockEditor;
const {
  PanelBody,
  SelectControl,
  RangeControl,
  ToggleControl,
  TextControl,
  Button,
  Modal
} = wp.components;
const {
  __
} = wp.i18n;

// Import icons data (will be generated by build process)
const icons = window.weIconBlocksIcons || window.webentwicklerinIcons || {};
registerBlockType('webentwicklerin/icon', {
  edit: ({
    attributes,
    setAttributes
  }) => {
    const {
      iconName,
      iconColor,
      backgroundColor,
      hoverIconColor,
      hoverBackgroundColor,
      width,
      height,
      linkUrl,
      linkTarget,
      linkRel,
      hasText,
      text,
      iconPosition,
      screenReaderOnly,
      gap,
      iconBorderWidth,
      iconBorderStyle,
      iconBorderColor,
      iconBorderRadius,
      hoverBorderColor,
      iconPadding,
      animation
    } = attributes;

    // Build inline styles
    const inlineStyles = {};

    // Icon-Farbe isoliert setzen, Textfarbe unverÃ¤ndert
    if (iconColor) {
      inlineStyles['--icon-base-color'] = iconColor;
    }
    if (backgroundColor) {
      inlineStyles['--icon-background-color'] = backgroundColor;
    }
    if (hoverIconColor) {
      inlineStyles['--hover-icon-color'] = hoverIconColor;
    } else if (iconColor) {
      inlineStyles['--hover-icon-color'] = iconColor;
    }
    if (hoverBackgroundColor) {
      inlineStyles['--hover-bg-color'] = hoverBackgroundColor;
    } else if (backgroundColor) {
      inlineStyles['--hover-bg-color'] = backgroundColor;
    }

    // Apply gap on wrapper only when there is no link and a value is set
    if (!linkUrl && hasText && gap !== undefined && gap !== null && gap !== '') {
      inlineStyles.gap = gap;
    }

    // Icon size control
    if (width) {
      inlineStyles['--icon-width'] = width;
    }
    if (height) {
      inlineStyles['--icon-height'] = height;
    }

    // Icon padding control
    if (iconPadding !== undefined && iconPadding !== null) {
      inlineStyles['--icon-padding'] = iconPadding;
    }

    // Icon Border Styles (scoped CSS vars; avoid "border-*" substrings so WP globals don't match)
    if (iconBorderWidth) {
      inlineStyles['--we-icon-frame-width'] = iconBorderWidth;
    }
    if (iconBorderStyle) {
      inlineStyles['--we-icon-frame-style'] = iconBorderStyle;
    }
    if (iconBorderColor) {
      inlineStyles['--we-icon-frame-color'] = iconBorderColor;
    }
    if (iconBorderRadius) {
      inlineStyles['--we-icon-frame-radius'] = iconBorderRadius;
    }
    if (hoverBorderColor) {
      inlineStyles['--hover-border-color'] = hoverBorderColor;
    }
    const blockProps = useBlockProps({
      style: inlineStyles,
      className: `icon-position-${iconPosition} ${hasText ? 'has-text' : 'no-text'} ${animation !== 'none' ? `icon-animation-${animation}` : ''}`
    });
    const iconOptions = Object.keys(icons).map(key => ({
      label: key.charAt(0).toUpperCase() + key.slice(1).replace('-', ' '),
      value: key
    }));

    // Icon Picker Modal Component
    const IconPickerModal = () => {
      const [isOpen, setIsOpen] = useState(false);
      const [searchTerm, setSearchTerm] = useState('');

      // Filter icons based on search term
      const filteredIcons = Object.keys(icons).filter(key => key.toLowerCase().includes(searchTerm.toLowerCase()));
      const handleIconSelect = iconKey => {
        setAttributes({
          iconName: iconKey
        });
        setIsOpen(false);
      };
      return createElement(Fragment, null, createElement(Button, {
        onClick: () => setIsOpen(true),
        variant: "secondary",
        style: {
          width: '100%',
          marginBottom: '10px'
        }
      }, iconName ? createElement(Fragment, null, createElement("span", {
        dangerouslySetInnerHTML: {
          __html: icons[iconName]
        },
        style: {
          width: '16px',
          height: '16px',
          marginRight: '8px',
          display: 'inline-flex',
          alignItems: 'center',
          justifyContent: 'center',
          overflow: 'hidden',
          flexShrink: 0
        }
      }), iconName.charAt(0).toUpperCase() + iconName.slice(1).replace('-', ' ')) : __('Select icon...', 'we-icon-blocks')), isOpen && createElement(Modal, {
        title: __('Select icon', 'we-icon-blocks'),
        onRequestClose: () => setIsOpen(false),
        className: "webentwicklerin-icon-picker-modal"
      }, createElement("div", {
        style: {
          marginBottom: '15px'
        }
      }, createElement(TextControl, {
        placeholder: __('Search icon...', 'we-icon-blocks'),
        value: searchTerm,
        onChange: setSearchTerm
      })), createElement("div", {
        style: {
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fill, minmax(60px, 1fr))',
          gap: '10px',
          maxHeight: '400px',
          overflowY: 'auto',
          padding: '10px 0'
        }
      }, filteredIcons.map(iconKey => createElement("button", {
        key: iconKey,
        onClick: () => handleIconSelect(iconKey),
        style: {
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          padding: '10px',
          border: iconName === iconKey ? '2px solid #007cba' : '1px solid #ddd',
          borderRadius: '4px',
          background: iconName === iconKey ? '#f0f8ff' : '#fff',
          cursor: 'pointer',
          transition: 'all 0.2s ease'
        },
        onMouseEnter: e => {
          if (iconName !== iconKey) {
            e.target.style.borderColor = '#007cba';
            e.target.style.background = '#f8f9fa';
          }
        },
        onMouseLeave: e => {
          if (iconName !== iconKey) {
            e.target.style.borderColor = '#ddd';
            e.target.style.background = '#fff';
          }
        }
      }, createElement("span", {
        dangerouslySetInnerHTML: {
          __html: icons[iconKey]
        },
        style: {
          width: '24px',
          height: '24px',
          marginBottom: '5px',
          fill: '#333',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          overflow: 'hidden',
          flexShrink: 0
        }
      }), createElement("small", {
        style: {
          fontSize: '10px',
          textAlign: 'center',
          color: '#666',
          wordBreak: 'break-all'
        }
      }, iconKey.replace(/-/g, ' ')))))));
    };
    const currentIcon = icons[iconName] || '';
    return createElement(Fragment, null, createElement(InspectorControls, null, createElement(PanelBody, {
      title: __('Icon Settings', 'we-icon-blocks'),
      initialOpen: true
    }, createElement(IconPickerModal, null), createElement(RangeControl, {
      label: __('Width (px)', 'we-icon-blocks'),
      value: parseInt(width),
      onChange: value => setAttributes({
        width: value + 'px'
      }),
      min: 16,
      max: 200
    }), createElement(RangeControl, {
      label: __('Height (px)', 'we-icon-blocks'),
      value: parseInt(height),
      onChange: value => setAttributes({
        height: value + 'px'
      }),
      min: 16,
      max: 200
    })), createElement(PanelBody, {
      title: __('Link & Text', 'we-icon-blocks'),
      initialOpen: false
    }, createElement(ToggleControl, {
      label: __('Use as link', 'we-icon-blocks'),
      checked: !!linkUrl,
      onChange: () => setAttributes({
        linkUrl: linkUrl ? '' : '#'
      })
    }), linkUrl && createElement(Fragment, null, createElement(TextControl, {
      label: __('Link URL', 'we-icon-blocks'),
      value: linkUrl,
      onChange: value => setAttributes({
        linkUrl: value
      }),
      placeholder: "https://..."
    }), createElement(SelectControl, {
      label: __('Open link in', 'we-icon-blocks'),
      value: linkTarget,
      options: [{
        label: __('Same window', 'we-icon-blocks'),
        value: '_self'
      }, {
        label: __('New window', 'we-icon-blocks'),
        value: '_blank'
      }],
      onChange: value => setAttributes({
        linkTarget: value,
        linkRel: value === '_blank' ? 'noopener noreferrer' : ''
      })
    })), createElement(ToggleControl, {
      label: __('Show text', 'we-icon-blocks'),
      checked: hasText,
      onChange: value => setAttributes({
        hasText: value
      })
    }), hasText && createElement(Fragment, null, createElement(TextControl, {
      label: __('Text', 'we-icon-blocks'),
      value: text,
      onChange: value => setAttributes({
        text: value
      })
    }), createElement(SelectControl, {
      label: __('Icon position', 'we-icon-blocks'),
      value: iconPosition,
      options: [{
        label: __('Left of text', 'we-icon-blocks'),
        value: 'left'
      }, {
        label: __('Right of text', 'we-icon-blocks'),
        value: 'right'
      }, {
        label: __('Above text', 'we-icon-blocks'),
        value: 'top'
      }, {
        label: __('Below text', 'we-icon-blocks'),
        value: 'bottom'
      }],
      onChange: value => setAttributes({
        iconPosition: value
      })
    }), createElement(TextControl, {
      label: __('Gap between icon and text', 'we-icon-blocks'),
      value: gap,
      onChange: value => setAttributes({
        gap: value
      }),
      placeholder: "0.5em",
      help: __('e.g. 0.5em, 8px, 1rem', 'we-icon-blocks')
    }), createElement(ToggleControl, {
      label: __('Text for screen readers only', 'we-icon-blocks'),
      checked: screenReaderOnly,
      onChange: value => setAttributes({
        screenReaderOnly: value
      })
    }))), createElement(PanelColorSettings, {
      title: __('Icon Colors', 'we-icon-blocks'),
      colorSettings: [{
        value: iconColor,
        onChange: newColor => setAttributes({
          iconColor: newColor
        }),
        label: __('Icon color', 'we-icon-blocks'),
        enableAlpha: true
      }, {
        value: hoverIconColor,
        onChange: newColor => setAttributes({
          hoverIconColor: newColor
        }),
        label: __('Icon color on hover', 'we-icon-blocks'),
        enableAlpha: true
      }]
    }), createElement(PanelColorSettings, {
      title: __('Background Colors', 'we-icon-blocks'),
      colorSettings: [{
        value: backgroundColor,
        onChange: newColor => setAttributes({
          backgroundColor: newColor
        }),
        label: __('Background', 'we-icon-blocks'),
        enableAlpha: true
      }, {
        value: hoverBackgroundColor,
        onChange: newColor => setAttributes({
          hoverBackgroundColor: newColor
        }),
        label: __('Background on hover', 'we-icon-blocks'),
        enableAlpha: true
      }]
    }), createElement(PanelColorSettings, {
      title: __('Border Colors', 'we-icon-blocks'),
      colorSettings: [{
        value: iconBorderColor,
        onChange: newColor => setAttributes({
          iconBorderColor: newColor
        }),
        label: __('Border color', 'we-icon-blocks'),
        enableAlpha: true
      }, {
        value: hoverBorderColor,
        onChange: newColor => setAttributes({
          hoverBorderColor: newColor
        }),
        label: __('Border color on hover', 'we-icon-blocks'),
        enableAlpha: true
      }]
    }), createElement(PanelBody, {
      title: __('Icon Border', 'we-icon-blocks'),
      initialOpen: false
    }, createElement(RangeControl, {
      label: __('Border Width', 'we-icon-blocks'),
      value: parseInt(iconBorderWidth) || 0,
      onChange: value => setAttributes({
        iconBorderWidth: value + 'px'
      }),
      min: 0,
      max: 10
    }), createElement(SelectControl, {
      label: __('Border Style', 'we-icon-blocks'),
      value: iconBorderStyle || 'solid',
      options: [{
        label: __('Solid', 'we-icon-blocks'),
        value: 'solid'
      }, {
        label: __('Dashed', 'we-icon-blocks'),
        value: 'dashed'
      }, {
        label: __('Dotted', 'we-icon-blocks'),
        value: 'dotted'
      }, {
        label: __('None', 'we-icon-blocks'),
        value: 'none'
      }],
      onChange: value => setAttributes({
        iconBorderStyle: value
      })
    }), createElement(RangeControl, {
      label: __('Border Radius', 'we-icon-blocks'),
      value: parseInt(iconBorderRadius) || 4,
      onChange: value => setAttributes({
        iconBorderRadius: value + 'px'
      }),
      min: 0,
      max: 50,
      step: 1,
      help: __('For circular icons, use 50% manually in CSS', 'we-icon-blocks')
    }), createElement(RangeControl, {
      label: __('Icon Padding', 'we-icon-blocks'),
      value: parseFloat(iconPadding) || 0.25,
      onChange: value => setAttributes({
        iconPadding: value === 0 ? '0' : value + 'em'
      }),
      min: 0,
      max: 2,
      step: 0.1,
      help: __('Inner spacing around the icon', 'we-icon-blocks')
    })), createElement(PanelBody, {
      title: __('Animation', 'we-icon-blocks'),
      initialOpen: false
    }, createElement(SelectControl, {
      label: __('Animation Type', 'we-icon-blocks'),
      value: animation,
      options: [{
        label: __('None', 'we-icon-blocks'),
        value: 'none'
      }, {
        label: __('Float Up', 'we-icon-blocks'),
        value: 'float-up'
      }, {
        label: __('Float Up Multiple', 'we-icon-blocks'),
        value: 'float-up-multiple'
      }, {
        label: __('Pulse', 'we-icon-blocks'),
        value: 'pulse'
      }, {
        label: __('Bounce', 'we-icon-blocks'),
        value: 'bounce'
      }, {
        label: __('Rotate', 'we-icon-blocks'),
        value: 'rotate'
      }, {
        label: __('Shake', 'we-icon-blocks'),
        value: 'shake'
      }],
      onChange: value => setAttributes({
        animation: value
      }),
      help: __('Select an animation for the icon', 'we-icon-blocks')
    }))), createElement("div", {
      ...blockProps
    }, linkUrl ? createElement("a", {
      href: linkUrl,
      target: linkTarget,
      rel: linkTarget === '_blank' ? 'noopener noreferrer' : linkRel,
      className: "wp-block-webentwicklerin-icon__link",
      style: hasText && gap !== undefined && gap !== null && gap !== '' ? {
        gap
      } : undefined,
      "aria-label": hasText && text ? `${text}` : `${iconName} icon`
    }, iconPosition === 'top' && createElement("div", {
      className: "wp-block-webentwicklerin-icon__inner",
      style: {
        width: width,
        height: height
      },
      "aria-hidden": hasText && text ? 'true' : undefined,
      dangerouslySetInnerHTML: {
        __html: currentIcon
      }
    }), hasText && text && iconPosition === 'top' && createElement("span", {
      className: screenReaderOnly ? 'screen-reader-text' : 'icon-text'
    }, text), (iconPosition === 'left' || iconPosition === 'right' || iconPosition === 'bottom') && createElement("div", {
      className: "wp-block-webentwicklerin-icon__inner",
      style: {
        width: width,
        height: height
      },
      "aria-hidden": hasText && text ? 'true' : undefined,
      dangerouslySetInnerHTML: {
        __html: currentIcon
      }
    }), hasText && text && iconPosition === 'bottom' && createElement("span", {
      className: screenReaderOnly ? 'screen-reader-text' : 'icon-text'
    }, text), hasText && text && (iconPosition === 'left' || iconPosition === 'right') && createElement("span", {
      className: screenReaderOnly ? 'screen-reader-text' : 'icon-text'
    }, text)) : createElement(Fragment, null, iconPosition === 'top' && createElement("div", {
      className: "wp-block-webentwicklerin-icon__inner",
      style: {
        width: width,
        height: height
      },
      "aria-hidden": hasText && text ? 'true' : undefined,
      dangerouslySetInnerHTML: {
        __html: currentIcon
      }
    }), hasText && text && iconPosition === 'top' && createElement("span", {
      className: screenReaderOnly ? 'screen-reader-text' : 'icon-text'
    }, text), (iconPosition === 'left' || iconPosition === 'right' || iconPosition === 'bottom') && createElement("div", {
      className: "wp-block-webentwicklerin-icon__inner",
      style: {
        width: width,
        height: height
      },
      "aria-hidden": hasText && text ? 'true' : undefined,
      dangerouslySetInnerHTML: {
        __html: currentIcon
      }
    }), hasText && text && iconPosition === 'bottom' && createElement("span", {
      className: screenReaderOnly ? 'screen-reader-text' : 'icon-text'
    }, text), hasText && text && (iconPosition === 'left' || iconPosition === 'right') && createElement("span", {
      className: screenReaderOnly ? 'screen-reader-text' : 'icon-text'
    }, text))));
  },
  save: ({
    attributes
  }) => {
    const {
      iconName,
      iconColor,
      backgroundColor,
      hoverIconColor,
      hoverBackgroundColor,
      width,
      height,
      linkUrl,
      linkTarget,
      linkRel,
      hasText,
      text,
      iconPosition,
      screenReaderOnly,
      gap,
      iconBorderWidth,
      iconBorderStyle,
      iconBorderColor,
      iconBorderRadius,
      hoverBorderColor,
      iconPadding,
      animation
    } = attributes;

    // Build inline styles for save
    const inlineStyles = {};
    if (iconColor) {
      inlineStyles['--icon-base-color'] = iconColor;
    }
    if (backgroundColor) {
      inlineStyles['--icon-background-color'] = backgroundColor;
    }
    if (hoverIconColor) {
      inlineStyles['--hover-icon-color'] = hoverIconColor;
    } else if (iconColor) {
      inlineStyles['--hover-icon-color'] = iconColor;
    }
    if (hoverBackgroundColor) {
      inlineStyles['--hover-bg-color'] = hoverBackgroundColor;
    } else if (backgroundColor) {
      inlineStyles['--hover-bg-color'] = backgroundColor;
    }

    // Apply gap on wrapper only when there is no link and a value is set
    if (!linkUrl && hasText && gap !== undefined && gap !== null && gap !== '') {
      inlineStyles.gap = gap;
    }

    // Icon size control
    if (width) {
      inlineStyles['--icon-width'] = width;
    }
    if (height) {
      inlineStyles['--icon-height'] = height;
    }

    // Icon padding control
    if (iconPadding) {
      inlineStyles['--icon-padding'] = iconPadding;
    }

    // Icon Border Styles (scoped CSS vars; avoid "border-*" substrings so WP globals don't match)
    if (iconBorderWidth) {
      inlineStyles['--we-icon-frame-width'] = iconBorderWidth;
    }
    if (iconBorderStyle) {
      inlineStyles['--we-icon-frame-style'] = iconBorderStyle;
    }
    if (iconBorderColor) {
      inlineStyles['--we-icon-frame-color'] = iconBorderColor;
    }
    if (iconBorderRadius) {
      inlineStyles['--we-icon-frame-radius'] = iconBorderRadius;
    }
    if (hoverBorderColor) {
      inlineStyles['--hover-border-color'] = hoverBorderColor;
    }
    const blockProps = useBlockProps.save({
      style: inlineStyles,
      className: `icon-position-${iconPosition} ${hasText ? 'has-text' : 'no-text'} ${animation !== 'none' ? `icon-animation-${animation}` : ''}`
    });
    const currentIcon = icons[iconName] || '';
    return createElement("div", {
      ...blockProps
    }, linkUrl ? createElement("a", {
      href: linkUrl,
      target: linkTarget,
      rel: linkTarget === '_blank' ? 'noopener noreferrer' : linkRel,
      className: "wp-block-webentwicklerin-icon__link",
      style: hasText && gap !== undefined && gap !== null && gap !== '' ? {
        gap
      } : undefined,
      "aria-label": hasText && text ? `${text} (${iconName})` : iconName
    }, hasText && text && iconPosition === 'top' && createElement("span", {
      className: screenReaderOnly ? 'screen-reader-text' : 'icon-text'
    }, text), createElement("div", {
      className: "wp-block-webentwicklerin-icon__inner",
      style: {
        width: width,
        height: height
      },
      "aria-hidden": hasText && text ? 'true' : undefined,
      dangerouslySetInnerHTML: {
        __html: currentIcon
      }
    }), hasText && text && iconPosition === 'bottom' && createElement("span", {
      className: screenReaderOnly ? 'screen-reader-text' : 'icon-text'
    }, text), hasText && text && (iconPosition === 'left' || iconPosition === 'right') && createElement("span", {
      className: screenReaderOnly ? 'screen-reader-text' : 'icon-text'
    }, text)) : createElement(Fragment, null, hasText && text && iconPosition === 'top' && createElement("span", {
      className: screenReaderOnly ? 'screen-reader-text' : 'icon-text'
    }, text), createElement("div", {
      className: "wp-block-webentwicklerin-icon__inner",
      style: {
        width: width,
        height: height
      },
      "aria-hidden": hasText && text ? 'true' : undefined,
      dangerouslySetInnerHTML: {
        __html: currentIcon
      }
    }), hasText && text && iconPosition === 'bottom' && createElement("span", {
      className: screenReaderOnly ? 'screen-reader-text' : 'icon-text'
    }, text), hasText && text && (iconPosition === 'left' || iconPosition === 'right') && createElement("span", {
      className: screenReaderOnly ? 'screen-reader-text' : 'icon-text'
    }, text)));
  }
});